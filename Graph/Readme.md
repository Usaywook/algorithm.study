# minimum spanning tree
disjoint set
union-find 알고리즘

신장 트리
모든 정점(n개)을 최소 간선 수(n-1)로 연결하면서 cycle이 없는 부분 그래프

최소 신장 트리
신장 트리 중 간선의 가중치 합이 최소가 되는 것

pseudo code
1. A - 신장 트리를 구성하는 간선을 공집합으로 초기화
2. while A 가 신장트리를 형성할 때까지
3. 신장트리를 만족(safe edge 판별)하도록 간선을 set A에 추가(union)
A를 반환

safe edge를 판별하는 방법
## Kruskal 알고리즘
부분 그래프 집합을 독립적인 트리 집합으로 바라보고 두 집합을 연결하는 edge중 least weight을 greedy하게 찾아서 연결.
이때 disjoint set 자료구조의 union 과 find 연산을 활용
pseudo code
1. 간선의 가중치를 오름차순 정렬 : E log E 의 시간 소요
2. 간선 마다: E * 
3. 사이클이 발생하지 않으면 최소신장트리에 포함; 상수 시간 소요
간선의 양끝 정점이 같은 집합인지(union-find 알고리즘 사용)를 고려하여 사이클이 발생하지 않은 것을 체크 
최종적으로 시간복잡도는 ElogE +  E = E log E

union-find 구현에서 가장 효율적인 자료구조는 tree
make set(x) -  x를 유일한 원소로하는 집합 형성
union(x,y) - 두 집합의 루트가 다르면 y 의 루트를  x 루트의 자손으로 넣어 집합을 합침 : find 연산에 dominant
find(x) - x의 대표(루트)값 반환: tree의 depth 에 비례하여 최대 n-1 
 
array로 구현하면
union(x,y) 은 y 집합의 정점 돌면서 parent를 x의 루트로 할당 O(N) 소요
find(x) 는 O(1) 소요

최적화 방법
find - 경로 압축을 사용하여 재귀 호출시 만나는 부모를 루트의 child 로 연결: 이렇게 하면 시간 복잡도 O(N) -> O(logN) 으로 줄어듦
union - 정점 별로 rank를 저장 후 rank가 작은 것을 큰 것의 chile로 연결한다.

활용
Kruskal MST 알고리즘에서 새로 추가할 간선의 양끝 정점이 같은 집합에 속해 있는지(사이클 형성 여부 확인)에 대해 검사하는 경우
초기에 {0}, {1}, {2}, … {n} 이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려는 경우
집합의 표현-백준1717번
어떤 사이트의 친구 관계가 생긴 순서대로 주어졌을 때, 가입한 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하는 경우
친구 네트워크-백준4195번

## Prim 알고리즘
시작 정점 부터 신장트리 집합을 단계적으로 확장하는 기법
1. 시작 정점을 집합에 포함
2. 인접한 정점 중 가중치 가장 간선으로 연결된 정점을 선택하여 트리 확장 : entry내 에서 |V| 반복
3. 트리가 N-1 간선을 가질 때까지 반복 : entry 수는 |V|
최종적으로 시간 복잡도는 |V|^2 

dense graph |E| >> |V| 라면 array로 구현하는 것이 더 효율적
일반적으로 sparse graph이므로 tree로 구현하는 것이 좋음.
